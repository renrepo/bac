// TESTEN OB ISEG MANUELL NE RAMPE FAHREN KANN
//j = i;
//spannung = -45.000 + j;
////end += i;
//_suspendEvent.Reset();
//iseg.RawIO.Write(String.Format(":VOLT {0},(@{1})\n", spannung.ToString("0.000"), 5)); // 3 decimal places
//Thread.Sleep(10000);
//garbage = iseg.RawIO.ReadString();
//Thread.Sleep(50);
//_suspendEvent.Set();
//LJM.eReadName(handle3, "AIN9", ref v_labjack);
//Thread.Sleep(50);
//sc += v_labjack;
//LJM.eReadName(handle3, "AIN9", ref v_labjack);
//Thread.Sleep(50);
//sc += v_labjack;
//LJM.eReadName(handle3, "AIN9", ref v_labjack);
//Thread.Sleep(50);
//sc += v_labjack;
//spannung2 = sc / (3*0.2040);
//bW_data.ReportProgress(i/900, spannung2.ToString("0.000"));
//Thread.Sleep(10);
//sc = 0;
//diff = spannung - spannung2;
////safer.safe_line(path + @"\gauss", end.ToString("000000000"));
//using (var file = new StreamWriter(path2 +  "data" + data_coutner + ".txt", true))
//{
//    file.WriteLine(spannung.ToString("0.000") + "\t" + spannung2.ToString("0.000") + "\t" + diff.ToString("0.000"));
//}
//Thread.Sleep(10);
//diff = 0;


// COUNTER IN DAUERSCHLEIFE
//                {
//                spannung = i*10;
//                //end += i;
//                //ct = int.Parse(tb_counter_ms.Text);
//                //tb_counter_ms.Text = ct.ToString();
//                LJM.eWriteName(handle_count, "DIO18_EF_INDEX", 7);
//                //LJM.eWriteName(handle_count, "DIO18_EF_OPTIONS", 1);
//                //LJM.eWriteName(handle_count, "DIO18_EF_CONFIG_A", 2);
//                //LJM.eWriteName(handle_count, "DIO18_EF_CONFIG_B", 100);
//                //LJM.eWriteName(handle_count, "FIO7", 0);
//                LJM.eWriteName(handle_count, "DIO18_EF_ENABLE", 1);
//                //LJM.eWriteName()
//                LJM.eReadName(handle_count, "DIO18_EF_READ_A", ref value2);
//                Thread.Sleep(1000);
//                LJM.eReadName(handle_count, "DIO18_EF_READ_A_AND_RESET", ref value3);
//                //  LJM.eWriteName(handle_count, "DIO18_EF_READ", ref value2);
//                double erg = value3 - value2;
//spannung2 = erg;
//                bW_data.ReportProgress(i / 900, spannung2.ToString("00000"));
//                //safer.safe_line(path + @"\gauss", end.ToString("000000000"));
//                using (var file = new StreamWriter(path2 + "data" + data_coutner + ".txt", true))





//double vpass;
//double vbias;
//double vstepsize;
//double tcount;
//int tcount2;
//double vLens;
//double slope;
//double overalltime;
//double slop;
//double v_analyser_min;
//double v_channeltron_out_min;
//double v_hemo_min;
//double v_hemi_min;
//double v_analyser_max;
//double v_channeltron_out_max;
//double v_hemo_max;
//double v_hemi_max;

//double v_analyser_max2;

//private async void btn_start_Click(object sender, EventArgs e)
//{
//    if (!bW_data.IsBusy)
//    {
//        end = 0;
//        //if (Al_anode.Checked){source = "Aluminium";}
//        //else {source = "Magnesium";}
//        myCurve = myPane.AddCurve("",
//        list1, Color.Black, SymbolType.None);
//        curr_time = now;
//        string u = tb_safe.Text + curr_time;
//        DirectoryInfo dl = Directory.CreateDirectory(Path.Combine(path + @"\Logfiles_XPS\", " " + curr_time + "_" + tb_safe.Text + "\\"));
//        path2 = dl.FullName;
//        using (var file = new StreamWriter(path2 + "data" + data_coutner + ".txt", true))
//        {
//            file.WriteLine("#UPS-spectrum" + Environment.NewLine);
//            file.WriteLine("#Date/time: \t{0}", DateTime.Now.ToString("yyyy-MM-dd__HH-mm-ss"));
//            file.WriteLine("" + Environment.NewLine);
//            file.WriteLine("#AK pressure: \t{0} \t{1}", tb_pressure.Text, "mbar");
//            file.WriteLine("#Pass energy: \t{0} \t{1}", vpass.ToString("0.0"), "eV");
//            file.WriteLine("#Voltage bias: \t{0} \t{1}", vbias.ToString("0.0"), "V");
//            file.WriteLine("#Voltage lenses: \t{0} \t{1}", vLens.ToString("0.0"), "V");
//            file.WriteLine("#Step width: \t{0} \t{1}", vstepsize.ToString("0.0"), "meV");
//            file.WriteLine("#Counttime: \t{0} \t{1}", tcount.ToString("0.0"), "ms");
//            file.WriteLine("" + Environment.NewLine);
//            file.WriteLine("#Slope: \t{0} \t{1}", slope.ToString("0.000"), "V");
//            file.WriteLine("#Counttime: \t{0} \t{1}", tcount.ToString("0.0"), "ms");
//            //file.WriteLine("#X-ray source: \t{0}", source + Environment.NewLine);
//            //file.WriteLine("#E_b \t counts");    
//            file.WriteLine("" + Environment.NewLine);
//            file.WriteLine("" + Environment.NewLine);
//            file.WriteLine("#E_kin \t Counts \t Int.Count \t V_ana. \t V_hemi \t V_hemo \t V_lens");
//            file.WriteLine("" + Environment.NewLine);
//        }

//        double k = ra / ri - ri / ra;
//        v_analyser_min = vpass - V_photon + vbias - 15;          //hier sollte kein elektron mehr im channeltron ankommen
//                                                                 //v_analyser_min = vpass - V_photon + vbias - 5;
//        v_hemo_min = v_analyser_min - (vpass * k * 0.3991) + 2.23;  //äußere hemispährenspannung aus passenergie nach spannugnsteiler (3.885M, 5.58M,269.5k))
//        v_hemi_min = v_hemo_min + vpass * k;               //liegt entsprechung die Spannungdifferenz drüber

//        // v_analyser_max = vpass +vbias;          //hier sollte auch das langsamste Elektron ankommen
//        v_analyser_max = v_analyser_min + V_photon + 5;
//        v_hemo_max = v_analyser_max - (vpass * k * 0.3991) + 2.23;  //äußere hemispährenspannung aus passenergie nach spannugnsteiler (3.885M, 5.58M,269.5k))
//        v_hemi_max = v_analyser_max + vpass * k;

//        v_channeltron_out_min = v_analyser_min + 3000;
//        v_channeltron_out_max = v_analyser_max + 3000;
//        double v_analyser_min2 = v_analyser_min + 3.35;
//        v_analyser_max2 = v_analyser_max + 3.35;
//        // startspannungen setzen

//        _suspendEvent.Reset();
//        iseg.RawIO.Write(String.Format(":CONF:RAMP:VOLT 10.000%/s\n"));     // Rampe auf 400 V/s
//        await Task.Delay(20);
//        garbage = iseg.RawIO.ReadString();
//        await Task.Delay(20);
//        iseg.RawIO.Write(String.Format(":VOLT {0},(@0)\n", v_hemi_min.ToString("0.000")));
//        await Task.Delay(10);
//        garbage = iseg.RawIO.ReadString();
//        await Task.Delay(10);
//        iseg.RawIO.Write(String.Format(":VOLT {0},(@1)\n", v_hemo_min.ToString("0.000")));
//        await Task.Delay(10);
//        garbage = iseg.RawIO.ReadString();
//        await Task.Delay(10);
//        //iseg.RawIO.Write(String.Format(":VOLT {0},(@5)\n", v_analyser_min2.ToString("0.000")));
//        //await Task.Delay(10);
//        //garbage = iseg.RawIO.ReadString();
//        //await Task.Delay(10);
//        iseg.RawIO.Write(String.Format(":VOLT {0},(@2)\n", vLens.ToString("0.000")));
//        await Task.Delay(10);
//        garbage = iseg.RawIO.ReadString();
//        await Task.Delay(10);
//        iseg.RawIO.Write(String.Format(":VOLT {0},(@4)\n", v_channeltron_out_min.ToString("0.000")));
//        await Task.Delay(10);
//        garbage = iseg.RawIO.ReadString();
//        await Task.Delay(10);
//        iseg.RawIO.Write(String.Format(":VOLT ON,(@0-5)\n"));
//        await Task.Delay(10);
//        readTextBox.Text = iseg.RawIO.ReadString();
//        await Task.Delay(10);


//        for (int i = 0; i < 12; i++)             //warten bis sich Spannungen gesetzt haben
//        {
//            LJM.eReadName(handle_v_analyser, "AIN3", ref LJ_analyser);
//            LJM.eReadName(handle_v_analyser, "AIN2", ref LJ_hemi);
//            LJM.eReadName(handle_v_analyser, "AIN1", ref LJ_hemo);
//            LJM.eReadName(handle_v_analyser, "AIN4", ref LJ_lens);
//            //LJ_analyser2 = LJ_analyser / 0.1956;
//            //LJ_analyser2 = LJ_analyser / 0.204;
//            LJ_hemi2 = LJ_hemi / 0.1962;
//            LJ_hemo2 = LJ_hemo / 0.1960;
//            LJ_analyser2 = LJ_hemo2 + (vpass * k * 0.3991);
//            LJ_lens2 = LJ_lens / 0.1962;
//            vm1.Text = LJ_hemi2.ToString("0.000");
//            vm2.Text = LJ_hemo2.ToString("0.000");
//            vm3.Text = LJ_lens2.ToString("0.000");
//            vm4.Text = LJ_analyser2.ToString("0.000");
//            vm5.Text = v_channeltron_out_max.ToString("0.000");

//            await Task.Delay(1000);
//            _suspendEvent.Set();
//        }

//        bW_data.RunWorkerAsync(); //run bW if it is not still running
//        btn_start.Enabled = false;
//        btn_can.Enabled = true;
//        tb_show.Enabled = true;
//        tb_safe.Enabled = false;
//    }

//    else
//    {
//        MessageBox.Show("BW busy!");
//    }
//}

//double sc = 0;
//double oldcounter = 0;
//double LJ_analyser2 = 0;
//double LJ_hemi2 = 0;
//double LJ_hemo2 = 0;
//double LJ_lens2 = 0;
//double k;
//double E_pass;
//double E_kin;

//private void bW_data_DoWork(object sender, DoWorkEventArgs e)
//{
//    _suspendEvent.Reset();
//    Stopwatch sw = new Stopwatch();
//    LJM.eWriteName(handle_count, "DIO18_EF_INDEX", 7);
//    iseg.RawIO.Write(String.Format(":CONF:RAMP:VOLT {0}%/s\n", slop * 0.001));
//    Thread.Sleep(20);
//    garbage = iseg.RawIO.ReadString();
//    Thread.Sleep(20);
//    iseg.RawIO.Write(String.Format(":VOLT {0},(@0)\n", v_hemi_max.ToString("0.000")));
//    Thread.Sleep(20);
//    garbage = iseg.RawIO.ReadString();
//    Thread.Sleep(20);
//    iseg.RawIO.Write(String.Format(":VOLT {0},(@1)\n", v_hemo_max.ToString("0.000")));
//    Thread.Sleep(20);
//    garbage = iseg.RawIO.ReadString();
//    Thread.Sleep(20);
//    //iseg.RawIO.Write(String.Format(":VOLT {0},(@5)\n", v_analyser_max2.ToString("0.000")));
//    //Thread.Sleep(20);
//    //garbage = iseg.RawIO.ReadString();
//    //Thread.Sleep(20);
//    iseg.RawIO.Write(String.Format(":VOLT {0},(@4)\n", v_channeltron_out_max.ToString("0.000")));
//    Thread.Sleep(20);
//    garbage = iseg.RawIO.ReadString();

//    LJM.eWriteName(handle_count, "DIO18_EF_ENABLE", 1);
//    while (true)
//    {
//        sw.Start();
//        LJM.eReadName(handle_count, "DIO18_EF_READ_A", ref intcounter);
//        LJM.eReadName(handle_v_analyser, "AIN3", ref LJ_analyser);
//        LJM.eReadName(handle_v_hemi, "AIN2", ref LJ_hemi);
//        LJM.eReadName(handle_v_hemo, "AIN1", ref LJ_hemo);
//        LJM.eReadName(handle_v_lens, "AIN4", ref LJ_lens);
//        //Thread.Sleep(tcount2);
//        sc = (intcounter - oldcounter) * 1000 / tcount;       //auf sekunde normieren
//                                                              //LJ_analyser2 = LJ_analyser / 0.1956;
//        LJ_hemi2 = LJ_hemi / 0.1962;
//        LJ_hemo2 = LJ_hemo / 0.1960;
//        LJ_analyser2 = LJ_hemo2 + (vpass * k * 0.3991);
//        LJ_lens2 = LJ_lens / 0.1962;

//        E_pass = (LJ_hemi2 - LJ_hemo2) / k;
//        //E_kin = E_pass - LJ_analyser2 - vbias;          // denn für detektierte e- gilt: 0 = Vbias + Ekin^0 + V_ana^0 - V_pass (^0: bezogen auf 0V)
//        E_kin = vbias - LJ_analyser2 + E_pass;          // ohne berücksichtigung de raustrittsarbeit
//        using (var file = new StreamWriter(path2 + "data" + data_coutner + ".txt", true))
//        {
//            file.WriteLine(E_kin.ToString("0.000") + "\t" + sc.ToString("00000") + "\t" + (intcounter * 1000 / tcount).ToString("00000000") + "\t" + LJ_analyser2.ToString("0.000") + "\t"
//                + LJ_hemi2.ToString("0.000") + "\t" + LJ_hemo2.ToString("0.000") + "\t" + LJ_lens2.ToString("0.000") + (LJ_hemo2 - LJ_hemi2).ToString("0.000") + "\t");
//        }


//        bW_data.ReportProgress(i / 900, sc.ToString("00000"));


//        oldcounter = intcounter;

//        if (bW_data.CancellationPending) // condition is true, if gauss is cancelled (CancelAsync())            
//        {
//            e.Cancel = true;
//            bW_data.ReportProgress(0);
//            LJM.eReadName(handle_count, "DIO18_EF_READ_A_AND_RESET", ref intcounter);
//            break; //warum? ist wichtig! vllt um aus for-loop zu kommen
//        }

//        while (sw.ElapsedMilliseconds < tcount2)
//        {
//            Thread.Sleep(1);
//        }
//        sw.Reset();

//    }
//    //safer.safe(path,list_gauss);
//    e.Result = sc; //stores the results of what has been done in bW
//    LJM.eReadName(handle_count, "DIO18_EF_READ_A_AND_RESET", ref intcounter);
//    _suspendEvent.Set();
//}

//private void bW_data_ProgressChanged(object sender, ProgressChangedEventArgs e)
//{
//    progressBar1.Value = e.ProgressPercentage;
//    vm1.Text = LJ_hemi2.ToString("0.000");
//    vm2.Text = LJ_hemo2.ToString("0.000");
//    vm3.Text = LJ_lens2.ToString("0.000");
//    vm4.Text = LJ_analyser2.ToString("0.000");
//    vm5.Text = v_channeltron_out_max.ToString("0.000");
//    //lb_perc_gauss.Text = e.ProgressPercentage.ToString() + " %";
//    tb_counter.Text = Convert.ToString(e.UserState);
//    // x = e.ProgressPercentage
//    //list1.Add(i, Convert.ToDouble(e.UserState));
//    list1.Add(E_kin, sc);
//    myCurve.AddPoint(E_kin, sc);

//    zedGraphControl1.Invalidate();
//    zedGraphControl1.AxisChange();
//}

//private void bW_data_RunWorkerCompleted(object sender, RunWorkerCompletedEventArgs e)
//{
//    //Ereignis! occures when bW operation has completed, has been cancelled or has raised an exception
//    if (e.Cancelled)
//    {
//        iseg.RawIO.Write(String.Format(":CONF:RAMP:VOLT 10.000%/s\n"));
//        Thread.Sleep(20);
//        garbage = iseg.RawIO.ReadString();
//        Thread.Sleep(20);
//        iseg.RawIO.Write(String.Format(":VOLT OFF,(@0-5)\n"));
//        Thread.Sleep(20);
//        readTextBox.Text = iseg.RawIO.ReadString();
//        Thread.Sleep(20);

//        tb_show.Text = "Stop!";
//        using (var file = new StreamWriter(path2 + "data" + data_coutner + ".txt", true))
//        {
//            file.WriteLine(Environment.NewLine + "#S C A N  C A N C E L L E D");
//        }
//        //  zedGraphControl1.MasterPane.GetImage().Save(Path.Combine(path2, "plot" + data_coutner + ".png"));
//        // safe_fig.Enabled = true;
//        showdata.Enabled = true;
//        fig_name.Enabled = true;
//        data_coutner += 1;
//        sc = 0;
//        intcounter = 0;
//    }

//    else if (e.Error != null)
//    {  // an exception instance, if an error occurs during asynchronous operation, otherwise null
//        tb_show.Text = e.Error.Message;
//    }

//    else
//    {
//        //tb_show.Text = Convert.ToString(e.UserState);
//        btn_can.Enabled = false;
//        btn_clear.Enabled = true;
//        fig_name.Enabled = true;
//        // safe_fig.Enabled = true;
//        showdata.Enabled = true;
//        // zedGraphControl1.MasterPane.GetImage().Save(Path.Combine(path2, "plot" + data_coutner + ".png"));
//        data_coutner += 1;
//    }

//}



















//    while (Math.Abs(LJ_hemi2 - (v_hemi_min + inkrement)) > abweichung || Math.Abs(LJ_hemo2 - (v_hemo_min + inkrement)) > abweichung || Math.Abs(LJ_analyser2 - (v_analyser_min + inkrement)) > abweichung)
//{
//    if (Math.Abs(LJ_hemi2 - (v_hemi_min + inkrement)) > abweichung)
//    {
//        v_hemi_min_korr = v_hemi_min_korr - (LJ_hemi2 - (v_hemi_min + inkrement));
//        iseg.RawIO.Write(String.Format(":VOLT {0},(@0)\n", (v_hemi_min_korr + inkrement).ToString("0.000")));
//        Thread.Sleep(10);
//        garbage = iseg.RawIO.ReadString();
//        Thread.Sleep(10);
//    }

//    if (Math.Abs(LJ_hemo2 - (v_hemo_min + inkrement)) > abweichung)
//    {
//        v_hemo_min_korr = v_hemo_min_korr - (LJ_hemo2 - (v_hemo_min + inkrement));
//        iseg.RawIO.Write(String.Format(":VOLT {0},(@1)\n", (v_hemo_min_korr + inkrement).ToString("0.000")));
//        Thread.Sleep(10);
//        garbage = iseg.RawIO.ReadString();
//        Thread.Sleep(10);
//    }

//    if (Math.Abs(LJ_analyser2 - (v_analyser_min + inkrement)) > abweichung)
//    {
//        v_analyser_min_korr = v_analyser_min_korr - (LJ_analyser2 - (v_analyser_min + inkrement));
//        iseg.RawIO.Write(String.Format(":VOLT {0},(@3)\n", (v_analyser_min_korr + inkrement).ToString("0.000")));
//        Thread.Sleep(10);
//        garbage = iseg.RawIO.ReadString();
//        Thread.Sleep(10);
//    }





//private void Mg_anode_CheckedChanged(object sender, EventArgs e)
//{
//    Mg_anode.BackColor = SystemColors.Control;
//    Al_anode.BackColor = SystemColors.Control;
//    if (Mg_anode.Checked)
//    {
//        Al_anode.Enabled = false;
//    }

//    else
//    {
//        Al_anode.Enabled = true;
//    }
//    enable_start();
//}



//private void Al_anode_CheckedChanged(object sender, EventArgs e)
//{
//    Al_anode.BackColor = SystemColors.Control;
//    Mg_anode.BackColor = SystemColors.Control;
//    if (Al_anode.Checked)
//    {
//        Mg_anode.Enabled = false;
//    }

//    else
//    {
//        Mg_anode.Enabled = true;
//    }
//    enable_start();
//}

//private void enable_start ()
//{
//    btn_start.Enabled = tb_safe.Text != string.Empty && (Al_anode.Checked || Mg_anode.Checked);
//}














 private void btn_load_Click(object sender, EventArgs e)
        {
            bool V_pass = double.TryParse(tb_v_pass.Text.Replace(',', '.'), out double v_pass);
            bool V_vor = double.TryParse(tb_v_vor.Text.Replace(',', '.'), out double v_vor);
            bool V_bind = double.TryParse(tb_v_bind.Text.Replace(',', '.'), out double v_bind);

            double k = ra / ri - ri / ra;

            if (V_pass & V_vor & V_bind)
            {
                v_ana_min = v_vor - V_photon + W_aus + v_pass;
                v_ana_max = v_vor + W_aus + v_pass;
                v_ana_bind = v_ana_min + v_bind;
                v_cem = v_ana_bind + delta_v_channeltron;
                delta_v = v_pass * k;
                //v_hem_in = v_ana_bind + delta_v / 2; // 50:50 spannungsteiler
                //v_hem_out = v_ana_bind - delta_v / 2; // 50:50 spannungsteiler
                v_hem_in = v_ana_bind + delta_v * 0.6;
                v_hem_out = v_ana_bind - delta_v*0.4;
                tb_ana_min.Text = v_ana_min.ToString("0.000");
                tb_ana_max.Text = v_ana_max.ToString("0.000");
                ch4_v.Text = v_ana_bind.ToString("0.000");
                ch5_v.Text = v_cem.ToString("0.000");
                ch1_v.Text = v_hem_in.ToString("0.000");
                ch2_v.Text = v_hem_out.ToString("0.000");
            }
            else
            {
                MessageBox.Show("Type in V_pass, V_vor and E_bind");
            }
        }


